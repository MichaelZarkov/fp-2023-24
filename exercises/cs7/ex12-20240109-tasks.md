# Упражнение 12 - Списъци, list comprehension. Алгебрични типове.

[код от упражнението](ex12-20240109-solutions.hs)

### Зад.0.
Припомнете си какво правят следните полезни функции за списъци. Очаква се от вас да можете да реализирате всяка една:
```haskell
map, filter, reverse, length, null, elem, take, drop, zip, zipWith, takeWhile, dropWhile, all, any
```
### Зад.1.
Да се напише функция `maxDistance`, която получава списък от точки (наредени двойки `(Double, Double)`) и връща дължината на най-дългата отсечка между някои две от тях.
```haskell
maxDistance [(-1.1, 1), (1.8, 2), (3, 1), (-1, -2)] -> 5.0
```
### Зад.2.
Да се напише функция `compress`, която по списък от стойности връща списък от наредени двойки от вида (<стойност>, <брой последователни срещания>):
```haskell
compress [1,1,2,3,3,3,4,2,2,2,2,1] -> [(1,2),(2,1),(3,3),(4,1),(2,4),(1,1)]
compress "abba" -> [('a',1),('b',2),('a',1)]
```
### Зад.3.
Да се напише функция `maxRepeated`, която по списък от стойности връща дължината на най-дългия подсписък, съставен от еднакви стойности:
```haskell
maxRepeated [1,1,2,3,3,3,4,2,2,2,2,1,1] -> 4
```
### Зад.4.
Да се напише функция `histogram`, която за всяка уникална стойност от даден списък връща списък от наредени двойки от вида (<стойност>, <общ брой срещания>):
```haskell
histogram [1,1,2,3,3,3,4,2,2,2,1,1] -> [(1,4),(2,4),(3,3),(4,1)]
```
### Зад.5*.
Да се напише функция `specialSort`, която приема като параметър списък от списъци и го сортира относно най-често срещания елемент във всеки от вътрешните списъци. Ако има няколко най-често срещани елемента, да се избира най-големия от тях:
```haskell
specialSort ["moo", "bee", "eve", "abracadabra", "abcdefg", "mama", "z"]
  -> ["abracadabra", "bee", "eve", "abcdefg", "mama", "moo", "z"]
-- в случая най-често срещаните елементи са съответно 'a', 'e', 'e', 'g', 'm', 'o', 'z'
-- наредбата не е уникална - няма проблем с това, нямаме изисквания за стабилност
```

### Interlude: въведение в алгебричните типове (Color, Shape, Maybe, Tree)

### Зад.6.
Да се напишат следните функции за списъци (както и техните типови сигнатури). Целта е те да се възползват от `Maybe`, за да бъдат тотални функции и никога да не връщат `error`.
- `safeHead`
- `safeTail`
- `safeUncons`
- `stripPrefix`
- `findIndex`
- `maybeToList :: [Maybe a] -> [a]`
- `mapMaybe :: (a -> Maybe b) -> [a] -> [b]`

### Зад.7.
Да се напише алгебричен тип данни `NonEmpty`, който символизира непразен списък. За него се напишат аналози на някои от най-често използваните функции за обикновени списъци (`head`, `tail`, `length`, `reverse`, `uncons`)

_Упътване:_ добавете `infixr 5` за конструктора от глава и опашка на този списък - да съвпада с `(:)`
