# Седмица 05 - Функции от по-висок ред за списъци - `foldr`, `foldl`, `map`, `filter`
За решението на всяка от задачите използвайте следните реализации на `foldr` и `foldl`, без да използвате директна рекурсия (където е възможно):
```scheme
(define (foldr operation null_value lst)
  (if (null? lst) null_value
      (operation (car lst)
          (foldr operation null_value (cdr lst)))))

(define (foldl operation null_value lst)
  (if (null? lst) null_value
      (foldl operation (operation null_value (car lst)) (cdr lst))))
```

## Задача 00 - `foldr1` и `foldl1`
Напишете функциите `foldr1` и `foldl1`, които правят същото като `foldr` и `foldl`, но не приемат начална стойност.

## Задача 01 - `filter` и `map`
Реалзирайте функциите `filter` и `map` чрез `foldr` и `foldr`.

## Задача 02 - Уникални елементи
Напишете функция, която премахва повтарящите се елементи в списък. Редът на елементите в резултата няма значение.

### Пример:
```scheme
(unique '(1 4 1 2 #t "hello" 1 "scheme" #t "world" "hello")) ; -> '(4 2 1 "scheme" #t "world" "hello")
```

## Задача 03 - Обединение и сечение
Напишете функции `union` и `intersection`, които правят съответно обединение и сечение на два списъка. Редът на елементите в резултата няма значение.

### Пример:
```scheme
(union '(1 2 4 "a" #t) '(5 6 1 "b" #f "a")) ; -> '(1 2 4 "a" #t 5 6 "b" #f)
(intersection '(1 2 4 "a" #t) '(5 6 1 "b" #f "a")) ; -> '(1 "a")
```

## Задача 04 - Reverse
Реализирайте функцията `reverse`, чрез `foldr` и `foldl`.

### Пример:
```scheme
(reverse* '(9 1 "A" 6 #f 25)) ; -> '(25 #f 6 "A" 1 9)
```

## Задача 05 - Any/All
Напишете функции `any?` и `all?`, които проверяват дали даден предикат е изпълнен за някой/за всеки елемент от списък.

### Пример:
```scheme
(any? even? (natural 6)) ; -> #t
(all? (lambda (x) (< x 10)) (natural 6)) ; -> #t
```

## Задача 06 - Сливане с функция
Напишете функция `zipWith*`, която приема функция и два списъка. Функцията да връща нов списък, който е равен на поелементното прилагане на функцията над двата списъка.

### Пример:
```scheme
(zipWith* + '(4 8 5) '(3 9 1 2)) ; -> '(7 17 6)
```

## Задача 07 - Вмъкване
Напишете функция, която вмъква елемент на правилното му място в сортиран списък.

### Пример:
```scheme
(insert 5 '(1 4 10)) ; -> '(1 4 5 10)
(insert 12 '(1 4 10)) ; -> '(1 4 10 12)
```

### Бонус:
Напишете функция, която сортира списък чрез алгоритъма `insertion sort`, която да ползва горната функция.

## Задача 08 - Quick Sort
Напишете функция, която сортира списък чрез алгоритъма `quick sort`.

### Пример:
```scheme
(quick-sort '(4 7 2 6 1)) ; -> '(1 2 4 6 7)
```

## Задача 09 - Най-малък елемент в списък
Напишете функция, която намира най-малкия елемент в списък. Задачата да се реши без каквато и да е рекурсия.

## Задача 10 - Средно аритметично
Напишете функция, която смята средното аритметично на произволен брой аргументи.

### Пример:
```scheme
(average 1 2 3 4 5) ; -> 3
```

## Задача 11 - Вариадичен `map`
Реализирайте вариант на `map`, който работи над произволен брой списъци.

### Пример:
```scheme
(map-var + '(1 2 3) '(4 5 6) '(7 8 9)) ; -> '(12 15 18)
```