# Седмица 13 - Двоични дървета и графи в Хаскел

```haskell
testGraph :: Graph Int
testGraph = Graph [(1, [2, 3, 4]),
                   (2, [1, 3, 5]),
                   (3, [1, 2, 4, 5]),
                   (4, [1, 3, 5]),
                   (5, [2, 3, 4])]
```

## Задача 01 - Двоични дървета
Решете задачите за двоични дървета от [предния път](https://github.com/triffon/fp-2023-24/tree/main/exercises/cs8/Week%2012%20-%20Algebraic%20Data%20Types).

## Задача 02 - Помощни функции за графи
Напишете следните помощни функции за графи:
- `vertices::Graph t -> [t]` - връща списък от върховете на граф;
- `neighbours::Eq t => t -> Graph t -> [t]` - връща всички съседи на възел в граф. Бонус: напишете безопасна версия с `Maybe`;
- `edge::Eq t => t -> t  -> Graph t -> Bool` - проверява дали има ребро между два възела в граф;
- `undirected::Eq t => Graph t -> Bool t` - проверява дали граф е неориентиран;
- `toEdgeList::Graph t -> [(t, t)]` - връща графа, представен като списък на ребрата.

## Задача 03 - Свързани компоненти
Напишете функция, която по подаден неориентиран граф и възел в него, връща списък от възлите, които са част от същата свързана компонента, в която се намира подадения връх.

### Бонус:
Напишете подобна функция, която връща силно свързана компонента в ориентиран граф.

### Пример:
```haskell
ghci> connectedComponent 1 testGraph -- [1,2,3,5,4]
```

## Задача 04 - Ойлеров граф
Напишете функция, която проверява дали неориентиран граф е [Ойлеров](https://en.wikipedia.org/wiki/Eulerian_path).

### Бонус:
Напишете функцията така, че да работи и за ориентиран граф.

### Пример:
```haskell
ghci> euler testGraph -- True
```

## Задача 05 - Всички пътища
Напишете функция, която по подадени начален и краен възел и граф, връща списък от всички пътища в графа, свързващи двата върха.