# Подготовка за писмен изпит

## Задача 01
Редицата на **Racamán** се дефинира по следния начин: 
- a0 = 0,
- ai = ai-1 – i, ако ai-1 > i и aᵢ ∉ {a0, …, ai-1},
- ai = ai-1 + i, иначе.

Да се дефинира функция `racaman`, която генерира потока от числа, представящ редицата на **Racamán**.
### Пример: 
```haskell
racaman → [0, 1, 3, 6, 2, 7, 13, 20, 12, 21, … ]
```

## Задача 02 
Да се напише функция `intervalTree`, която преобразува двоично дърво от числа в ново дърво със същата структура, в което стойността във всеки възел е заменена с наредена двойка, представляваща най-малкия интервал, съдържащ всички стойности в съответното поддърво.

### Пример:
![Img](./intervalTree.png)

### Бонус: 
`intervalTree` да работи за време `O(n)` в най-лошия случай.

## Задача 03
Разглеждаме ациклични графи с представяне по ваш избор. **Семейство** наричаме множество от възли F такова, че за всеки възел u ∈ F е вярно, че във F са всичките му деца и нито един негов родител или всичките му родители и нито едно негово дете.

а) Да се реализира функция `isFamily`, която проверява дали дадено множество от възли е семейство в даден граф;

б) Да се реализира функция `minIncluding`, която по даден възел u намира минимално множество от възли, което е семейство и съдържа u (ако такова семейство има).

### Упътване: 
Възможен подход за решение е да се добавят всички деца на u, след това всички техни родители, след това всички техни деца и така докато няма какво да се добавя, след което да се провери дали полученото множество е семейство. Ако не е, да се направи втори опит за построяване на семейство, добавяйки  първо родителите на u, след това техните деца и т. н. Втори провал означава, че такова семейство няма.

## Задача 04 
База данни се описва с име (низ) и размер в MB (цяло число). Сървър за данни се описва с име (низ), капацитет в MB (цяло число) и списък от бази данни. Нека е даден списък от сървъри **l**.

а) Да се реализира функция `maxFree`, която намира името на този сървър в **l**, който има най-много свободно място (разликата между капацитета на сървъра и сумата на размерите на базите данни).

б) Да се реализира функция `tryRemove`, която по име на сървър **s** проверява дали е възможно всички бази от данни от **s** да се прехвърлят по другите сървъри от **l** (по не повече от една база на сървър) така, че **s** да бъде изключен. Функцията да връща новия списък от сървъри след прехвърлянето, ако е възможно, или оригиналния списък **l**, ако не е възможно.

### Упътване: 
Достатъчно е да се подредят сървърите и базите данни съответно по свободно място и размер и да се провери дали има съответствие. Ако такова няма, значи разпределение не е възможно.

### Бонус:
Да се реши б) без ограничението "не повече от една база на сървър". Не е нужно решението да е оптимално по време.
