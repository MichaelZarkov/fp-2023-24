# 10. Въведение в Haskell - продължение

![Haskell meme](../assets/10-haskell-lazy.jpg)

---

# Материал:

## λ-функции

```haskell
-- (lambda (x y z) (+ x y z))
\x -> \y -> \z -> x + y + z
\x y z -> x + y + z
```

## HOF върху списъци

### `map`
```haskell
-- (map (lambda (x) (+ x 1)) '(1 2 3))
map (\x -> x + 1) [1, 2, 3] -- [2, 3, 4]
```

### `filter`
```haskell
-- (filter (lambda (x) (= (remainder x 2) 0)) (range 1 10))
filter even [1..10] -- [2, 4, 6, 8, 10]
```

### `foldr`

```haskell
-- (foldr (lambda (x y) (+ x y)) 0 (range 1 10))
foldr (+) 0 [1..10] -- 55
```

## Потоци

```haskell
-- (define ones (my-stream-cons 1 ones)) <- да
-- (define ones (cons 1 ones)) <- не ста'а

ones :: [Int]
ones = 1 : ones

nats :: [Int]
nats = [0..]

nats' :: [Int]
nats' = natsFrom 0
 where
  natsFrom x = x : natsFrom (x + 1)

-- Не ни трябват `stream-_` версии на познатите ни функции върху списъци
take 5 nats -- [0, 1, 2, 3, 4, 5]
take 5 (drop 5 nats) -- [6, 7, 8, 9, 10]

map (\x -> (quot x 2)) (filter even nats) -- [0, 1, 2, ...], hmmmmm
```

## Функция VS Оператор

```haskell
-- Защо можем да викаме `+` така
1 + 2

-- а пък не можем така?
-- + 1 2

-- В Haskell има значение от името на една функция дали тя ще е "просто функция" или оператор
-- Една функция наричаме (не само ние, Haskell също) ако името ѝ се състои само от символи (без букви)

a +-//^ b = 5

1 +-//^ 3 -- 5

-- Ако пък името ѝ се състои само от букви (+ долни черти, единични кавички и т.н., не е важно) тогава си е нормална префиксна функция

fa123__'' x y = x + y

fa123__'' 5 1 -- 6

-- Haskell обаче ни позволява да ползваме функция "все едно е оператор", както и оператор "все едно е функция"
-- Това става по следният начин

f a b = a + b -- функция

f 1 2 -- 3
1 `f` 2 -- 3

-- Слагането на ` около името на функция я "кара да се превърне в оператор"
-- Пример за функция, която предпочитаме да ползваме като оператор е `elem`

elem :: Int -> [Int] -> Bool
elem s (x:xs) = if s == x then True else elem s xs
elem _ [] = False

elem 5 [1..10] -- True
5 `elem` [1..10] -- True

-- Почти можем да го прочетем като "5 елемент ли е на [1..10]?", което ни помага да запомним в какъв ред са аргументите (кое е елемента, кое е списъка)

-- Опако, слагането на скоби около оператор го "кара да се превърне във (нормална) функция"

(+) 1 2 -- 3

-- Точно затова при декларираме оператори ползваме този синтаксис

(+-//^) :: Int -> Int -> Int
a +-//^ b = 5

-- Напълно валидно е и в самата дефиниция са го ползваме

(+-//^) :: Int -> Int -> Int
(+-//^) a b = 5

-- Което важи и за първият случай

elem :: Int -> [Int] -> Bool
s `elem` (x:xs) = if s == x then True else elem s xs
_ `elem` [] = False
```

## Отсичане

```haskell
-- Доста често ни се налага да пишем функции, подобни на тези
\x -> x + 1
\x -> 5 * x

-- Haskell ни позволява да "отсечем" един от аргументите на извикване на опратор, което има същата семантика като да имаме "дупка"/аргумент на мястото на изтритото:

f x = x + 1
f = \x -> x + 1
f = (+1)

g x = 5 * x
g = \x -> 5 * x
g = (5*)

map (+1) [1..3] -- [2, 3, 4]
```

> [!NOTE]
> Отсичането може да се случи както за левия, така и за десния аргумент

## Curry

```haskell
-- Може да сте се чудили защо в типовете на функции имаме толкова много стрелки

f :: Int -> String -> (Int -> Int) -> [Int] -> Int
f a b c d = 5

-- Всъщност, ако леко си присвием очите, `->` прилича леко на оператор, но работи върху типове, а не върху аргументи/константи/данни.
-- Този "оператор" се оказва, че е точно такъв, даже е дясно-асоциативен
-- Това означава, че

f :: Int -> String -> (Int -> Int) -> [Int] -> Int

-- е същото като

f :: (Int -> (String -> ((Int -> Int) -> ([Int] -> Int))))

-- Демек, реално `f` е функция САМО НА ЕДИН АРГУМЕНТ, която връща ДРУГА ФУНКЦИЯ, която "очаква" ОСТАНАЛИТЕ АРГУМЕНТИ

-- Хмммм, но това как работи? Оказва се, че да работи всичко изрядно, опратора за прилагане (викане) "шпация" може да го мислим за ляво-асоциативен
-- Това означава, че

f 1 "banica" (+1) [1,2]

-- е същото като

(((((f) 1) "banica") (+1)) [1,2])

-- Демек, реално като викаме "функция с няколко аргумента", ние просто подаваме един по един аргументите на функцията, върната от последното даване на един аргумент

-- Супер полезно следствие от това е, че можем да скипнем правенето на много lambd-и

sum :: [Int] -> Int
sum = \xs -> foldr (+) 0 xs

-- Можем да го съкратим до

sum = foldr (+) 0

-- Можем да проверим, че типа съответства (приемайки, че foldr работи само с Int-ове)

--       op                     nv     xs       result
foldr :: (Int -> Int -> Int) -> Int -> [Int] -> Int

-- :t foldr
-- (Int -> Int -> Int) -> (Int -> ([Int] -> Int))
--
-- :t foldr (+)
-- Int -> ([Int] -> Int)
--
-- :t foldr (+) 0
-- [Int] -> Int
```

> [!NOTE]
> Може да ни чуете да наричаме този метод за опростяване (да пишем `f` вместо `\x -> f x`) "η-редуциране". Ако ви е интересно защо - питайте в междучасието :D

## Стандартни функции върху списъци

```haskell
-- `take` и `drop` взимаме първите/всички освен първите `n` елемента от списък
take 2 [1..5] -- [1, 2]
drop 2 [1..5] -- [3, 4, 5]

-- repeat прави безкраен списък от един елемент
repeat 0 -- [0, 0, 0, ...]

-- cycle прави подобно нещо, но със списък
cycle [1, 2, 3] -- [1, 2, 3, 1, 2, 3, 1, ...]
```

---

## List comprehension

Haskell ни дава доста сила когато дефинираме списъци. Освен класическото

```haskell
[1, 2, 3]
```

можем да изразяваме списъци чрез т.нар. "set builder notation" (от теорията на множествата / ДСТР), а именно

```haskell
evens xs = [x | x <- xs, x `rem` 2 == 0]

-- четем: "четните елемент на xs са всички x-ове, които идват от xs и се делят на 2 с остатък 0"
```

Инсрументариумът ни се състои от следните неща:

1. `[... | ..., m <- f x y z,...]`, където `f x y z :: [a]` и `m :: a`, а `x`, `y` и `z` или са външни променливи, или са дефинирани подобно по-наляво от `m`
2. `[... | ..., p, ...]`, където `p :: Bool`
3. `[f x y z ... | ...]`, където `x`, `y` и `z` са дефинирани по правило 1

```haskell
pairs xs ys = [(x, y) | x <- xs, y <- ys]

-- четем: "... са всички наредени двойки (x, y), където x идва от xs, а y идва от ys"

-- ако имахме `[(x, y) | x <- xs, y <- ys]`
pairs [1,2] ["a", "b"]
[(1, "a"), (1, "b"), (2, "a"), (2, "b")]

-- ако имахме `[(x, y) | y <- ys, x <- xs]`
pairs [1,2] ["a", "b"]
[(1, "a"), (2, "a"), (1, "b"), (2, "b")]

-- забележете реда, в който се избира елемент от xs и от ys
```

```haskell
matrix :: Int -> Int -> [[(Int, Int)]]
matrix rows cols = [[(row, col) | col <- [1..cols]] | row <- [1..rows]]

-- четем: "... е всичките редове (всичките (row, col), където col идва от [1..cols]), където row идва от [1..rows]"

matrix 3 4
[ [(1, 1), (1, 2), (1, 3), (1, 4)]
, [(2, 1), (2, 2), (2, 3), (2, 4)]
, [(3, 1), (3, 2), (3, 3), (3, 4)]
]
```

```haskell
coolPairs :: [(Int, Int)]
coolPairs = [(square, x) | square <- [1..], x <- [1..square], x * x == square]

take 10 coolPairs
[(1,1),(4,2),(9,3),(16,4),(25,5),(36,6),(49,7),(64,8),(81,9),(100,10)]


coolPairs' = [(square, x) | square <- [1..], x <- [1..], x * x == square]

-- ако не ограничим `x` отгоре, то Haskell ще се опита (примерно за square = 2) да търси в безкрайността такова `x`, че `x * x == square`

take 2 coolPairs'
[(1,1) -- <hangs>...
```

> [!NOTE]
> "Операциите" в list comprehension-а се случват "линейно" (отляво-надясно): `[x | x <- xs, even x]` е валидно, докато `[x | even x, x <- xs]` не е

# Задачи:

Дефинирайте следните функции[^1] работещи върху списъци (и измислете техните типове, по-възможност колкото може по-общи[^2]):

> [!NOTE]
> Понеже някои от тези функции ги има вече в прелюдието, то ще трябва изрично да ги "скрием", че да можем да ги имплементираме ние:
> ```haskell
> import Prelude hiding (length, foldr, foldl, reverse, product, map, filter, zip, zipWith)
> ```

> [!NOTE]
> Ако се затруднявате с типовете на функциите пробвайте първо да ги имплементирате само за Int-ове (където вече знаете, че се иска списък или Bool), а след като ги имплементирате може да помислите как могат да се генаранизират[^2]

1. Намира дължината на списъка `xs`

```haskell
length :: _
length xs = undefined
```

2. Проверява дали съществува елемент в `xs`, за който е изпълнен предикатът `p` (мислете `any`)

```haskell
exists :: _
exists p xs = undefined
```

3. Проверява дали предикатът `p` е изпълнен за всички елементи на списъка `xs` (мислете `all`)

```haskell
forall :: _
forall p xs = undefined
```

4. Проверява дали елементът `x` се съдържа в списъка `xs` (какво значи "съдържа"?)

```haskell
member :: _
member x xs = undefined
```

5. Прилага `f` върху всеки елемент на списъка `xs`

```haskell
map :: _
map f xs = undefined
```

6. Съставя нов списък, съдържащ само елементите на `xs`, за които е изпълнен предикатът `p`

```haskell
filter :: _
filter p xs = undefined
```

7. Добавя елемента `x` на края на списъка `xs`

```haskell
push :: _
push x xs = undefined
```

8. (**БОНУС**: 1т.) Връща списък с елементите на `xs` в обратен ред

```haskell
reverse :: _
reverse xs = undefined
```

9. Вкарва елемента `x` на позиция `n` в списъка `xs` (ако `n` е след края на `xs`, вкарваме `x` накрая)

```haskell
insert :: _
insert x n xs = undefined
```

10. Пресмята `op xs[0] (op xs[1] (op xs[2] ... (op xs[n] init) ... )))` (ако имаме подаден празен списък, резултатът е `init`).

```haskell
foldr :: _
foldr op init xs = undefined
```

11. Пресмята `op ( ... (op (op (op xs[0]) xs[1]) xs[2]) ... xs[n] ) init` (ако имаме подаден празен списък, резултатът е `init`).

```haskell
foldl :: _
foldl op init xs = undefined
```

12. Намира произведението на елементите в списък от числа

```haskell
product :: _
product = undefined
```

13. (**БОНУС**: 0.5т.) "зип"-ва два списъка заедно (в наредени двойки)

```haskell
zip :: _
zip = undefined

-- >>> zip [1,2,3] ["a", "b", "c"]
-- [(1, "a"), (2, "b"), (3, "c")]
```

14. (**БОНУС**: 0.5т) "зип"-ва два списъка заедно (използвайки комбинираща функция)

```haskell
zipWith :: _
zipWith = undefined

-- >>> zipWith (+) [1, 2, 3] [2, 4, 6]
-- [3, 6, 9]
```

15. Списък от всички естествени числа

```haskell
nats :: _
nats = undefined

-- >>> take 10 nats == [1..10]
-- True
```

15. (**БОНУС**: 1т.) Списък, получен от zig-zag-ването на два други такива

```haskell
interleave :: _
interleave = undefined

-- >>> interleave [1,2,3] [4,5,6]
-- [1, 4, 2, 5, 3, 6]

-- >>> interleave nats (map (*2) nats)
-- [1, 2, 2, 4, 3, 6, 4, 8, 5, 10, 6, 12,  ...]

-- >>> interleave (filter odd nats) (filter even nats)
-- [1, 2, 3, 4, 5, 6, ...]
```

16. (**БОНУС**: 1т.) Списъкът от всички питагорови тройки (ползвайте list comprehension)

```haskell
pythagoreanTriples :: _
pythagoreanTriples = undefined
```

- (**БОНУС**: 1т.) Същото, но само простите питагорови тройки (НОД-а на 3-те страни да е 1), където страните са подредени в нарастващ ред, без повторки

17. (**БОНУС**: 2т.) Списъкът от всички прости чиста, позовавайки се на ["решетото на Ератостен"](https://bg.wikipedia.org/wiki/%D0%A0%D0%B5%D1%88%D0%B5%D1%82%D0%BE_%D0%BD%D0%B0_%D0%95%D1%80%D0%B0%D1%82%D0%BE%D1%81%D1%82%D0%B5%D0%BD)

```haskell
primes :: _
primes = undefined

-- >>> take 10 $ primes
-- [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
```

[^1]:
> [!NOTE]
> Всички тези функции сме ги имплементирали вече, но на `scheme`, демек може да си реферирате към `scheme`-ските имплементации ако зацепите

[^2]:
> [!NOTE]
> Примерно, ако трябваше да типизираме функцията `(.)` (композиция), то бихме могли да ѝ дадем един от следните типове:
> ```haskell
> (.) :: (Int -> Int) -> (Int -> Int) -> Int -> Int
> (.) :: (Int -> String) -> (Char -> Int) -> Char -> String
> (.) :: (a -> a) -> (a -> a) -> a -> a
> (.) :: (b -> a) -> (a -> b) -> a -> a
> (.) :: (b -> c) -> (a -> b) -> a -> c
> ```
> Помислете защо бихме нарекли последният тип "най-общ", какво е "ограничаващото"/"необщото" във всеки от другите?
