# Упражнение 2

![Recursion Meme](https://miro.medium.com/v2/resize:fit:640/0*CVTYEDxT1jtWVl3t)

---

# Рекурсия

  Вече констатирахме, че всички са поне втори курс, така че знаете какво е рекурсия и можем да си спестим базовите обясняванки.

  Скачаме направо на интересното.

## Примитивна vs. опашкова рекурсия

```scheme
; Нека разгледаме n!
(define (factorial n)
  (if (= n 0)
    1
    (* n (factorial (- n 1)))))

; ако бележим "factorial"с "f",
; то изчислителния процес на (f 5) ще изглежда така:
;(f 5)
;(* 5 (f 4))
;(* 5 (* 4 (f 3)))
;(* 5 (* 4 (* 3 (f 2))))
;(* 5 (* 4 (* 3 (* 2 (f 1)))))
;(* 5 (* 4 (* 3 (* 2 (* 1 (f 0))))))
;(* 5 (* 4 (* 3 (* 2 (* 1 1)))))
;(* 5 (* 4 (* 3 (* 2 1))))
;(* 5 (* 4 (* 3 2)))
;(* 5 (* 4 6))
;(* 5 24)
;120

; памет: O(n)
; време: О(n)

; Това е същински рекурсивен процес (примитивна рекурсия)
; защото има отложените операции.

; Използвайки вложена дефиниция:
(define (factorial-iter n)

  (define (iter product i)
    ; тук ползваме допълнителния аргумент като
    ; допълнителна променлива, в която натрупваме резултата
    (if (zero? i)
      product
      ; Тук изчислението се случва в аргументите
      (iter (* i product)
            (- i 1))))

  ; Извикваме помощната функция
  (iter 1 n))

; Вече изчислителния процес изглежда така:
;(factorial-iter 5)
;(iter 1   5)
;(iter 5   4)
;(iter 20  3)
;(iter 60  2)
;(iter 120 1)
;(iter 120 0)
;120

; време: O(n)
; памет: O(1)

; Това е линеен итеративен процес заради липсата
; на отложени операции.
; (опашкова рекурсия)

; Scheme третира опашковата рекурсия като итерация.
; Ако всички рекурсивни извиквания в една функция
; са опашкови, тя генерира линеен итеративен процес.


; Тази реализация поражда дървовиден рекурсивен процес
(define (fib n)
  (if (< n 2)
    n
    (+ (fib (- n 1))
       (fib (- n 2)))))

; време: O(2^n)

; Можем ли да го направим итеративно?
; Да, с динамично програмиране.

; Ще намираме числата на фибоначи последователно
; и ще помним предходните две.
; Така няма да трябва да ги изчисляваме всеки път
; когато ни потрябват.
(define (fib-iter n)
  (define (iter n1 n2 i)
    (if (zero? i)
      n2
      (iter n2
            (+ n1 n2)
            (- i 1))))
  (iter 0 1 n))

; Нека видим разликата във времето за изпълнение:
; (time (fib 42))
; (time (fib-iter 42))

; Тогава защо изобщо бихме използвали примитивна рекурсия,
; вместо опашкова (итерация)?
```

# Задачи

1. Дефинирайте функция `(sum-digits n)`, която смята сумата от цифрите на числото $n$.

```scheme
(sum-digits 123) ;; => 6
```

1. Дефинирайте функция `(count-divisors n)`, която връща броя на делителите на числото $n$.

```scheme
(count-divisors 6) ;; => 4 ; делителите на 6 са 1,2,3,6
```

1. Дефинирайте предикат `(prime? n)`, който определя дали $n$ е просто число.

```scheme
(prime? 1000000000000000000000007) ;; => #t
```

1. Дефинирайте предикат `(increasing-digits? n)`, който определя дали цифрите в записа за числото $n$ са подредени във възходящ ред

```scheme
(increasing-digits 123) ;; => #t
(increasing-digits 132) ;; => #f
```

1. Дефинирайте предикат `(ends-with? n k)`, който проверява дали числото $n$ завършва с числото $k$.

```scheme
(ends-with? 152352363123 2363123) ;; => #t
(ends-with? 152352363123 3023)    ;; => #f
```

  - В допълнение, може да дефинирате предикат `(automorphic? n)`, който проверява дали $n$ е автоморфно. Едно число е _автоморфно_, ако квадратът му завършва на него.

```scheme
(automorphic? 4)  ;; => #f
(automorphic? 5)  ;; => #t
(automorphic? 6)  ;; => #t
(automorphic? 11) ;; => #f
```

1. Дефинирайте предикат `(perfect? n)`, която проверява дали дадено естествено число е съвършено.

> **NOTE**: Съвършени числа са [тези](https://oeis.org/A000396), за които сумата на всичките им делители (без самото число) е равна на същото число.


```scheme
(perfect? 191561942608236107294793378084303638130997321548169216) ;; => #t
(perfect? 8126) ;; => #f
```

1. Дефинирайте функция `(binary-to-decimal n)`, която по дадено число в двоична бройна система, връща същото число в десетична бройна система

```scheme
(decimal-to-binary 101) ;; => 5
```

1. Дефинирайте функция `(decimal-to-binary n)`, която по дадено число в десетична бройна система, връща същото число в двоична бройна система

```scheme
(decimal-to-binary 5) ;; => 101
```
